---
phase: 02-core-calculator-logic
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/Calculator.fs
  - src/App.fs
  - src/App.fsproj
  - tests/Tests.fs
  - tests/Tests.fsproj
  - .config/dotnet-tools.json
  - package.json
autonomous: true

must_haves:
  truths:
    - "Calculator types compile successfully with dotnet build"
    - "Fable CLI installed as dotnet tool and can compile F# to JS"
    - "Test project compiles and Fable.Mocha test runner executes (even with zero meaningful tests)"
    - "npm test script runs the full test pipeline (fable compile + mocha run)"
  artifacts:
    - path: "src/Calculator.fs"
      provides: "Calculator domain types (Model, Msg, MathOp, MathOperationResult)"
      contains: "type Model"
    - path: "tests/Tests.fs"
      provides: "Test entry point with Fable.Mocha skeleton"
      contains: "Mocha.runTests"
    - path: "tests/Tests.fsproj"
      provides: "Test project referencing src/App.fsproj and Fable.Mocha"
      contains: "Fable.Mocha"
    - path: ".config/dotnet-tools.json"
      provides: "Fable CLI tool manifest"
      contains: "fable"
  key_links:
    - from: "tests/Tests.fsproj"
      to: "src/App.fsproj"
      via: "ProjectReference"
      pattern: "ProjectReference.*App\\.fsproj"
    - from: "src/App.fsproj"
      to: "src/Calculator.fs"
      via: "Compile Include before App.fs"
      pattern: "Compile Include=\"Calculator.fs\""
---

<objective>
Set up test infrastructure (Fable CLI, Fable.Mocha, test project) and define calculator domain types so that TDD can begin in the next plan.

Purpose: Establish the testing pipeline and type definitions that Plan 02-02 (TDD) needs as foundation. Without test infrastructure, TDD cannot start. Without types, tests cannot reference Model/Msg.
Output: Working `npm test` command, calculator types in Calculator.fs, skeleton test file
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-calculator-logic/02-RESEARCH.md
@.planning/phases/01-foundation-and-tooling/01-02-SUMMARY.md
@src/App.fs
@src/App.fsproj
@src/Main.fs
@package.json
@vite.config.js
@.config/dotnet-tools.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test infrastructure with Fable.Mocha</name>
  <files>.config/dotnet-tools.json, tests/Tests.fsproj, tests/Tests.fs, package.json</files>
  <action>
1. Install Fable as a dotnet tool:
   ```bash
   dotnet tool install fable
   ```
   This updates `.config/dotnet-tools.json` to include the fable tool.

2. Create `tests/Tests.fsproj` — a separate F# project for tests:
   ```xml
   <Project Sdk="Microsoft.NET.Sdk">
     <PropertyGroup>
       <TargetFramework>net10.0</TargetFramework>
     </PropertyGroup>
     <ItemGroup>
       <Compile Include="Tests.fs" />
     </ItemGroup>
     <ItemGroup>
       <PackageReference Include="Fable.Mocha" Version="2.17.0" />
     </ItemGroup>
     <ItemGroup>
       <ProjectReference Include="../src/App.fsproj" />
     </ItemGroup>
   </Project>
   ```

3. Create `tests/Tests.fs` — skeleton test file:
   ```fsharp
   module Tests

   open Fable.Mocha
   open App

   let smokeTests = testList "Smoke" [
       test "init returns a model" {
           let model, _ = init ()
           Expect.pass ()
       }
   ]

   let allTests = testList "CalTwo" [
       smokeTests
   ]

   [<EntryPoint>]
   let main args =
       Mocha.runTests allTests
   ```

4. Install mocha as npm dev dependency:
   ```bash
   npm install mocha --save-dev
   ```

5. Add test scripts to `package.json`:
   - `"test:compile"`: `"dotnet fable tests/Tests.fsproj -o tests/out --noCache"`
   - `"test:run"`: `"npx mocha tests/out/Tests.js --timeout 10000"`
   - `"test"`: `"npm run test:compile && npm run test:run"`

6. Restore the test project:
   ```bash
   dotnet restore tests/Tests.fsproj
   ```
  </action>
  <verify>
Run `npm test` and confirm:
- Fable compiles tests/Tests.fsproj to tests/out/Tests.js without errors
- Mocha executes and shows "1 passing" for the smoke test
- Exit code is 0
  </verify>
  <done>
`npm test` succeeds end-to-end: Fable compiles test F# to JS, mocha runs the compiled tests, smoke test passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Define calculator domain types and wire into project</name>
  <files>src/Calculator.fs, src/App.fs, src/App.fsproj</files>
  <action>
1. Create `src/Calculator.fs` with calculator domain types. Follow RESEARCH.md Pattern 1 (discriminated unions):

   ```fsharp
   module Calculator

   /// Math operations the calculator supports
   type MathOp =
       | Add
       | Subtract
       | Multiply
       | Divide

   /// Result of a math operation (handles divide-by-zero)
   type MathResult =
       | Success of float
       | DivideByZeroError

   /// Calculator messages (user actions)
   type Msg =
       | DigitPressed of int       // 0-9
       | DecimalPressed            // .
       | OperatorPressed of MathOp // +, -, ×, ÷
       | EqualsPressed             // =
       | ClearPressed              // C/AC

   /// Calculator state
   type Model = {
       Display: string
       PendingOp: (MathOp * float) option
   }
   ```

   Key design decisions:
   - `DigitPressed of int` (0-9) is simpler than individual digit DU cases per research Pattern 1. Using int 0-9 reduces boilerplate while keeping type safety (validated in update function).
   - `PendingOp` stores `(MathOp * float) option` — the operator and first operand, per research Pattern 3 (left-to-right evaluation with pending operation).
   - `MathResult` discriminated union handles divide-by-zero gracefully per research Pattern for Division by Zero.
   - `Display: string` stores what user sees, per research.

2. Update `src/App.fsproj` to include `Calculator.fs` BEFORE `App.fs` (F# compilation order matters):
   ```xml
   <ItemGroup>
     <Compile Include="Calculator.fs" />
     <Compile Include="App.fs" />
     <Compile Include="Main.fs" />
   </ItemGroup>
   ```

3. Update `src/App.fs` to use the new Calculator types. Replace the existing placeholder types with imports from Calculator module:
   ```fsharp
   module App

   open Feliz
   open Elmish
   open Calculator

   let init () : Model * Cmd<Msg> =
       { Display = "0"; PendingOp = None }, Cmd.none

   let update (msg: Msg) (model: Model) : Model * Cmd<Msg> =
       // Placeholder — will be implemented via TDD in Plan 02-02
       model, Cmd.none

   let view (model: Model) (dispatch: Msg -> unit) =
       Html.div [
           prop.style [ style.padding 20; style.fontFamily "sans-serif" ]
           prop.children [
               Html.h1 "CalTwo Calculator"
               Html.div [
                   prop.style [
                       style.fontSize 24
                       style.padding 10
                       style.backgroundColor "#f0f0f0"
                       style.textAlign.right
                       style.minHeight 40
                   ]
                   prop.text model.Display
               ]
               Html.p "Phase 2: Calculator logic in progress..."
           ]
       ]
   ```

   The update function is a stub returning unchanged model — Plan 02-02 (TDD) will implement the actual logic.
  </action>
  <verify>
1. Run `dotnet build src/App.fsproj` — must compile without errors
2. Run `npm run dev` briefly (start and immediately Ctrl+C) — must start without fatal errors
3. Run `npm test` — smoke test still passes (verifies test project can reference Calculator types)
  </verify>
  <done>
Calculator.fs defines Model, Msg, MathOp, MathResult types. App.fs uses Calculator types with stub update function. Both main project and test project compile successfully. Dev server starts. Tests pass.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/App.fsproj` compiles without errors
2. `dotnet build tests/Tests.fsproj` compiles without errors
3. `npm test` runs end-to-end: Fable compiles, mocha executes, smoke test passes
4. `npm run dev` starts dev server without fatal errors
5. Calculator types (Model, Msg, MathOp, MathResult) exist in src/Calculator.fs
6. tests/Tests.fsproj has ProjectReference to src/App.fsproj
</verification>

<success_criteria>
- npm test executes successfully with at least 1 passing test
- Calculator domain types defined and importable from test project
- Dev server still works (no regression from Phase 1)
- Fable CLI available via dotnet tool
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-calculator-logic/02-01-SUMMARY.md`
</output>
