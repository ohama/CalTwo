---
phase: 02-core-calculator-logic
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - tests/Tests.fs
  - src/Calculator.fs
  - src/App.fs
autonomous: true

must_haves:
  truths:
    - "Pressing digits 0-9 appends to display correctly"
    - "Pressing decimal point adds '.' once; second press is ignored"
    - "Pressing operator stores pending operation and first operand"
    - "Pressing equals evaluates pending operation and shows result"
    - "Chained operations evaluate left-to-right (2+3+4 = 9)"
    - "Division by zero shows 'Error' in display"
    - "Clear resets to initial state (display='0', no pending op)"
    - "All edge cases pass: multiple decimals, leading zeros, negative results"
  artifacts:
    - path: "tests/Tests.fs"
      provides: "Comprehensive unit tests for all calculator operations and edge cases"
      contains: "testList"
      min_lines: 100
    - path: "src/Calculator.fs"
      provides: "Pure calculator service functions (doMathOp, updateDisplay, parseDisplay)"
      contains: "doMathOp"
    - path: "src/App.fs"
      provides: "Elmish update function implementing all calculator state transitions"
      contains: "let update"
  key_links:
    - from: "src/App.fs"
      to: "src/Calculator.fs"
      via: "open Calculator; uses doMathOp, types"
      pattern: "open Calculator"
    - from: "tests/Tests.fs"
      to: "src/App.fs"
      via: "open App; calls init, update"
      pattern: "open App"
---

<objective>
Implement the complete calculator logic using TDD: write failing tests first (RED), then implement pure update function to pass all tests (GREEN).

Purpose: All 13 requirements (INP-01, INP-02, INP-04, OPS-01-06, DSP-01-03) are satisfied through pure state transitions tested without UI.
Output: Fully tested calculator logic with all arithmetic operations, edge cases, and error handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-calculator-logic/02-RESEARCH.md
@.planning/phases/02-core-calculator-logic/02-01-SUMMARY.md
@src/Calculator.fs
@src/App.fs
@tests/Tests.fs
</context>

<tasks>

<task type="auto">
  <name>RED: Write comprehensive failing tests for calculator logic</name>
  <files>tests/Tests.fs</files>
  <action>
Replace the smoke test in `tests/Tests.fs` with comprehensive test suites. Write ALL tests before any implementation. Tests call `App.init` and `App.update` (which currently returns model unchanged, so tests will fail).

Structure tests into these groups:

**1. Digit Entry tests:**
- Pressing 1 shows "1" (replaces initial "0")
- Pressing 1 then 2 shows "12"
- Pressing 1, 2, 3 shows "123"
- Pressing 0 when display is "0" keeps "0" (no leading zeros)
- Pressing 5 then 0 shows "50" (trailing zero OK)

**2. Decimal Point tests:**
- Pressing decimal shows "0." (appends to zero)
- Pressing 3 then decimal shows "3."
- Pressing 3, decimal, 1 shows "3.1"
- Pressing 3, decimal, decimal — second decimal ignored, still "3."
- Pressing 3, decimal, 1, decimal — second decimal ignored, still "3.1"

**3. Basic Operations tests:**
- 2 + 3 = shows "5"
- 9 - 4 = shows "5"
- 3 × 4 = shows "12"
- 8 ÷ 2 = shows "4"

**4. Left-to-Right Evaluation tests:**
- 2 + 3 + 4 = shows "9" (evaluates 2+3=5 when second + pressed, then 5+4=9)
- 10 - 3 + 2 = shows "9"
- 2 × 3 + 1 = shows "7"

**5. Division by Zero tests:**
- 5 ÷ 0 = shows "Error"
- After error, pressing digit resets (e.g., press 3 → shows "3")

**6. Clear tests:**
- Press some digits, then Clear → display="0", pendingOp=None
- After operation, Clear resets everything

**7. Edge Case tests:**
- Pressing equals with no pending operation does nothing (display unchanged)
- Negative result: 3 - 8 = shows "-5"
- Decimal arithmetic: 1.5 + 2.5 = shows "4"
- Large number: 999999999 + 1 = shows "1000000000"
- Pressing operator right after init: should store 0 as first operand
- Pressing operator twice: second operator replaces first

**Test implementation pattern** (from RESEARCH.md Pattern 5):
```fsharp
test "2 + 3 = 5" {
    let model, _ = App.init ()
    let m1 = model |> App.update (DigitPressed 2) |> fst
    let m2 = m1 |> App.update (OperatorPressed Add) |> fst
    let m3 = m2 |> App.update (DigitPressed 3) |> fst
    let m4 = m3 |> App.update EqualsPressed |> fst
    Expect.equal m4.Display "5" "2 + 3 should equal 5"
}
```

Important: Use `Calculator.DigitPressed`, `Calculator.OperatorPressed`, etc. (or `open Calculator` at top of test file). The Msg type is defined in Calculator module.
  </action>
  <verify>
Run `npm test`:
- Fable compilation succeeds (tests compile)
- Mocha shows ALL tests FAILING (expected: update function is a stub)
- No compilation errors in test file
  </verify>
  <done>All tests compile and run, but fail because update function is a stub. Test count should be 20+ covering all requirements.</done>
</task>

<task type="auto">
  <name>GREEN: Implement calculator logic to pass all tests</name>
  <files>src/Calculator.fs, src/App.fs</files>
  <action>
Implement the calculator logic to make ALL tests pass.

**1. Add service functions to `src/Calculator.fs`** (below the existing type definitions):

```fsharp
/// Execute a math operation, returning Success or DivideByZeroError
let doMathOp (op: MathOp) (a: float) (b: float) : MathResult =
    match op with
    | Add -> Success (a + b)
    | Subtract -> Success (a - b)
    | Multiply -> Success (a * b)
    | Divide ->
        if b = 0.0 then DivideByZeroError
        else Success (a / b)

/// Parse display string to float. Returns 0.0 for invalid/empty strings.
let parseDisplay (display: string) : float =
    match System.Double.TryParse(display) with
    | true, v -> v
    | false, _ -> 0.0

/// Format a float for display. Remove trailing ".0" for whole numbers.
let formatResult (value: float) : string =
    let s = string value
    if s.EndsWith(".0") then s.[..s.Length - 3]
    elif s.EndsWith("0") && s.Contains(".") then
        s.TrimEnd('0').TrimEnd('.')
        |> fun trimmed -> if trimmed = "" then "0" else trimmed
    else s
```

Note on `formatResult`: Ensure whole number results display without decimal (e.g., 5.0 → "5"), but preserve meaningful decimals (e.g., 3.14 → "3.14"). Test with actual Fable output — F# `string 5.0` may produce "5" in Fable/JS context. Adjust formatting logic based on test results.

**2. Implement `update` function in `src/App.fs`:**

Handle each message type following RESEARCH.md Pattern 2 and Pattern 3:

```fsharp
let update (msg: Msg) (model: Model) : Model * Cmd<Msg> =
    match msg with
    | DigitPressed digit when digit >= 0 && digit <= 9 ->
        let digitStr = string digit
        let newDisplay =
            if model.Display = "0" || model.Display = "Error" then
                digitStr
            else
                model.Display + digitStr
        { model with Display = newDisplay }, Cmd.none

    | DigitPressed _ ->
        // Invalid digit, ignore
        model, Cmd.none

    | DecimalPressed ->
        if model.Display.Contains(".") || model.Display = "Error" then
            model, Cmd.none  // Already has decimal or in error state
        else
            { model with Display = model.Display + "." }, Cmd.none

    | OperatorPressed op ->
        if model.Display = "Error" then
            model, Cmd.none
        else
            match model.PendingOp with
            | Some (pendingOp, firstNum) ->
                // Evaluate pending operation first (left-to-right)
                let secondNum = parseDisplay model.Display
                match doMathOp pendingOp firstNum secondNum with
                | Success result ->
                    let resultStr = formatResult result
                    { Display = resultStr; PendingOp = Some (op, result) }, Cmd.none
                | DivideByZeroError ->
                    { Display = "Error"; PendingOp = None }, Cmd.none
            | None ->
                let currentNum = parseDisplay model.Display
                { Display = "0"; PendingOp = Some (op, currentNum) }, Cmd.none

    | EqualsPressed ->
        match model.PendingOp with
        | Some (op, firstNum) ->
            let secondNum = parseDisplay model.Display
            match doMathOp op firstNum secondNum with
            | Success result ->
                { Display = formatResult result; PendingOp = None }, Cmd.none
            | DivideByZeroError ->
                { Display = "Error"; PendingOp = None }, Cmd.none
        | None ->
            model, Cmd.none

    | ClearPressed ->
        { Display = "0"; PendingOp = None }, Cmd.none
```

Key behaviors:
- DigitPressed: Replace "0" with digit, otherwise append. Reset from "Error" state.
- DecimalPressed: Append "." only if not already present. Ignore in error state.
- OperatorPressed: If pending op exists, evaluate it first (left-to-right). Store new op + current value.
- OperatorPressed after another operator (no new digit): second operator replaces first. Current display value is re-parsed (same number, different operator stored).
- EqualsPressed: Evaluate pending op if exists, clear pending op. If no pending op, do nothing.
- ClearPressed: Reset to init state.

After implementation, the display should reset to "0" when operator is pressed (ready for next number input). But there's a subtlety: when user presses operator right after the result of a previous operation, the display should show the intermediate result, not "0". Handle this by checking if we just evaluated a pending operation.

**Refinement for OperatorPressed:** When there's no pending operation, after storing `PendingOp = Some(op, currentNum)`, set Display to the current value (not "0") because pressing an operator shouldn't visually change the display yet. The display resets when the NEXT digit is pressed. So add a flag or handle this differently:

Actually, the simpler approach: When OperatorPressed with no pending op, keep display as-is. When the NEXT DigitPressed comes in, it replaces the display. This requires tracking whether we're starting a new number entry. Add a boolean flag to Model:

Update `Calculator.fs` Model type:
```fsharp
type Model = {
    Display: string
    PendingOp: (MathOp * float) option
    StartNew: bool  // true = next digit replaces display instead of appending
}
```

Then in update:
- DigitPressed: If `StartNew`, replace display with digit (instead of appending)
- OperatorPressed: Set `StartNew = true`
- EqualsPressed: Set `StartNew = true` (result shown, next digit starts fresh)
- ClearPressed: Reset everything including `StartNew = false`

This is the standard calculator behavior pattern.
  </action>
  <verify>
Run `npm test`:
- ALL tests pass (green)
- No compilation errors
- Test output shows all test groups passing

Also run:
- `dotnet build src/App.fsproj` — no errors
- `npm run dev` briefly — dev server starts, no fatal errors
  </verify>
  <done>All 20+ unit tests pass. Calculator handles: digit entry (0-9), decimal point (single only), four operations (+, -, ×, ÷), equals, chained left-to-right evaluation, division by zero ("Error"), clear, and edge cases (leading zeros, negative results, decimal arithmetic).</done>
</task>

</tasks>

<verification>
1. `npm test` shows ALL tests passing (20+ tests, 0 failures)
2. Tests cover: digit entry, decimal, all 4 operations, equals, chained operations, divide-by-zero, clear, edge cases
3. `dotnet build src/App.fsproj` compiles without errors
4. `npm run dev` starts without fatal errors
5. Update function is pure (returns Model * Cmd, uses Cmd.none, no side effects)
6. Calculator logic handles left-to-right evaluation correctly
</verification>

<success_criteria>
- All unit tests pass via `npm test`
- Every requirement covered: INP-01 (digits), INP-02 (decimal), INP-04 (clear), OPS-01-06 (operations + div-by-zero), DSP-01-03 (display state changes)
- Update function is pure and testable without side effects
- Edge cases: multiple decimals rejected, leading zeros handled, negative results display correctly
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-calculator-logic/02-02-SUMMARY.md`
</output>
